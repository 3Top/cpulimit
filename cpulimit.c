/**
 *
 * cpulimit - a cpu limiter for Linux
 *
 * Copyright (C) 2005-2008, by:  Angelo Marletta <marlonx80@hotmail.com>
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 *
 **********************************************************************
 *
 * This is a simple program to limit the cpu usage of a process
 * If you modify this code, send me a copy please
 *
 * Date:    9/2/2008
 * Version: 1.2
 * Get the latest version at: http://cpulimit.sourceforge.net/
 *
 * Changelog:
 * - reorganization of the code, splitted in more source files
 * - control function process_monitor() optimized by eliminating an unnecessary loop
 * - experimental support for multiple control of children processes and threads
 * - cpu count detection, i.e. if you have 4 cpu, it is possible to limit up to 400%
 * - in order to avoid deadlock, cpulimit prevents to limit itself
 * - option --path eliminated, use --exe instead
 * - minor enhancements and bugfixes
 *
 */


#include <getopt.h>
#include <stdio.h>
#include <fcntl.h>
#include <stdlib.h>
#include <time.h>
#include <sys/time.h>
#include <unistd.h>
#include <sys/types.h>
#include <signal.h>
#include <sys/resource.h>
#include <string.h>
#include <dirent.h>
#include <errno.h>
#include <string.h>
#include "process.h"
#include "procutils.h"
#include "list.h"

//some useful macro
#define MIN(a,b) (a<b?a:b)
#define MAX(a,b) (a>b?a:b)

//the process pool, containing the main process and all the processes directly
//or indirectly generated by the main process
struct list process_pool;
//pid of the main process
int pid;
//pid of cpulimit
int cpulimit_pid;

//CONFIGURATION VARIABLES
//verbose mode
int verbose = 0;
//lazy mode (exits if there is no process)
int lazy = 0;
//priority values of the daemon (nice)
int high_priority_value = -10;
int low_priority_value = 10;
int default_priority_value;

//name of this program (cpulimit)
char *program_name;

//how many cpu do we have?
int get_cpu_count()
{
	FILE *fd;
	int cpu_count = 0;
	char line[100];
	fd = fopen("/proc/stat", "r");
	if (fd < 0)
		return 0; //are we running Linux??
	while (fgets(line,sizeof(line),fd)!=NULL) {
		if (strncmp(line, "cpu", 3) != 0) break;
		cpu_count++;
	}
	fclose(fd);
	return cpu_count - 1;
}


//return ta-tb in microseconds (no overflow checks, so better watch out!)
inline unsigned long timediff(const struct timespec *ta,const struct timespec *tb)
{
	unsigned long us = (ta->tv_sec-tb->tv_sec)*1000000 + (ta->tv_nsec/1000 - tb->tv_nsec/1000);
	return us;
}

inline unsigned long long tv_diff(struct timeval *tv1, struct timeval *tv2)
{
	unsigned long long ret;
	ret = ((unsigned long long)(tv2->tv_sec - tv1->tv_sec)) * 1000000ULL;
	ret += tv2->tv_usec - tv1->tv_usec;
	return ret;
}

//SIGINT and SIGTERM signal handler
void quit(int sig)
{
	//let all the processes continue if stopped
	//todo...
//	kill(target_proc.pid, SIGCONT);
	exit(0);
}

void print_caption()
{
	printf("\n%%CPU\twork quantum\tsleep quantum\tactive rate\n");
}

void print_usage(FILE *stream, int exit_code)
{
	fprintf(stream, "Usage: %s TARGET [OPTIONS...]\n",program_name);
	fprintf(stream, "   TARGET must be exactly one of these:\n");
	fprintf(stream, "      -p, --pid=N        pid of the process\n");
	fprintf(stream, "      -e, --exe=FILE     name of the executable program file or absolute path name\n");
	fprintf(stream, "   OPTIONS\n");
	fprintf(stream, "      -l, --limit=N      percentage of cpu allowed from 0 to 100 (required)\n");
	fprintf(stream, "      -v, --verbose      show control statistics\n");
	fprintf(stream, "      -z, --lazy         exit if there is no suitable target process, or if it dies\n");
	fprintf(stream, "      -h, --help         display this help and exit\n");
	exit(exit_code);
}

void limit_process(int pid, float limit)
{
	//control time slot in microseconds
	//each slot is splitted in a working slice and a sleeping slice
	int slot=100000;
	//slice of the slot in which the process is allowed to run
	struct timespec twork;
	//slice of the slot in which the process is stopped
	struct timespec tsleep;
	//when the last twork has started
	struct timespec startwork;
	//when the last twork has finished
	struct timespec endwork;
	//initialization
	memset(&twork, 0, sizeof(struct timespec));
	memset(&tsleep, 0, sizeof(struct timespec));
	memset(&startwork, 0, sizeof(struct timespec));
	memset(&endwork, 0, sizeof(struct timespec));
	
	//last working time in microseconds
	unsigned long workingtime = 0;

	if (verbose) print_caption();

//	float pcpu_avg=0;
	int i = 0;

//TODO: SPOSTARE NEL WHILE?
//FARE ALGORITMO DI CONTROLLO MULTIPLO E HO FINITO!
	//ok, the main process was found
	struct process *proc = malloc(sizeof(struct process));
	//process initialization
	process_init(proc, pid);
	//add the main process to the process pool
	add_elem(&process_pool, proc);

	//here we should have high priority, for time precision
	while(1) {

		if (i%10==0) {
			int *ch=NULL;
			get_sub_processes(pid, &ch);
			exit(0);
//TODO: update process pool
		}

		//estimate how much the controlled process is using the cpu in the working interval
		struct cpu_usage cu;
		if (process_monitor((struct process*)first_elem(&process_pool), workingtime, &cu)==-1) {
			fprintf(stderr,"Process %d dead!\n", proc->pid);
			return;
		}

		//cpu actual usage of process (range 0-1)
		//1 means that the process is using 100% cpu
		float pcpu = cu.pcpu;
		//rate at which we are keeping active the process (range 0-1)
		//1 means that the process is using all the twork slice
		float workingrate = cu.workingrate;

		//adjust work and sleep time slices
		if (pcpu>0) {
			twork.tv_nsec = MIN(slot*limit*1000/pcpu*workingrate,slot*1000);
		}
		else if (pcpu==0) {
			twork.tv_nsec = slot*1000;
		}
		else if (pcpu==-1) {
			//not yet a valid idea of cpu usage
			pcpu = limit;
			workingrate = limit;
			twork.tv_nsec = MIN(slot*limit*1000,slot*1000);
		}
		tsleep.tv_nsec = slot*1000-twork.tv_nsec;

		//update average usage
//		pcpu_avg=(pcpu_avg*i+pcpu)/(i+1);

		if (verbose && i%10==0 && i>0) {
			printf("%0.2f%%\t%6ld us\t%6ld us\t%0.2f%%\n",pcpu*100,twork.tv_nsec/1000,tsleep.tv_nsec/1000,workingrate*100);
		}

		if (limit>0 && limit<1) {
			//resume process
			if (kill(proc->pid,SIGCONT)!=0) {
				fprintf(stderr,"Process %d dead!\n", proc->pid);
				return;
			}
		}

		//now the process is allowed to run
		clock_gettime(CLOCK_REALTIME,&startwork);
		nanosleep(&twork,NULL);
		clock_gettime(CLOCK_REALTIME,&endwork);
		workingtime = timediff(&endwork,&startwork);

		if (limit<1) {
			//stop the process, it has worked enough
			if (kill(proc->pid,SIGSTOP)!=0) {
				fprintf(stderr,"Process %d dead!\n",proc->pid);
				return;
			}
			//now the process is forced to sleep
			nanosleep(&tsleep,NULL);
		}
		i++;
	}
}

int main(int argc, char **argv) {

	//get program name
	char *p=(char*)memrchr(argv[0],(unsigned int)'/',strlen(argv[0]));
	program_name = p==NULL?argv[0]:(p+1);
	cpulimit_pid = getpid();

	//argument variables
	const char *exe = NULL;
	int perclimit = 0;
	int pid_ok = 0;
	int process_ok = 0;
	int limit_ok = 0;

	//parse arguments
	int next_option;
    int option_index = 0;
	//A string listing valid short options letters
	const char* short_options = "p:e:l:vzh";
	//An array describing valid long options
	const struct option long_options[] = {
		{ "pid",        required_argument, NULL,     'p' },
		{ "exe",        required_argument, NULL,     'e' },
		{ "limit",      required_argument, NULL,     'l' },
		{ "verbose",    no_argument,       &verbose, 'v' },
		{ "lazy",       no_argument,       &lazy,    'z' },
		{ "help",       no_argument,       NULL,     'h' },
		{ 0,            0,                 0,         0  }
	};

	do {
		next_option = getopt_long(argc, argv, short_options,long_options, &option_index);
		switch(next_option) {
			case 'p':
				pid = atoi(optarg);
				pid_ok = 1;
				process_ok = 1;
				break;
			case 'e':
				exe = optarg;
				process_ok = 1;
				break;
			case 'l':
				perclimit = atoi(optarg);
				limit_ok = 1;
				break;
			case 'v':
				verbose = 1;
				break;
			case 'z':
				lazy = 1;
				break;
			case 'h':
				print_usage(stdout, 1);
				break;
			case '?':
				print_usage(stderr, 1);
				break;
			case -1:
				break;
			default:
				abort();
		}
	} while(next_option != -1);

	if (!process_ok) {
		fprintf(stderr,"Error: You must specify a target process, by name or by PID\n");
		print_usage(stderr, 1);
		exit(1);
	}
	if (pid_ok && exe!=NULL) {
		fprintf(stderr, "Error: You must specify exactly one process, by name or by PID\n");
		print_usage(stderr, 1);
		exit(1);
	}
	if (!limit_ok) {
		fprintf(stderr,"Error: You must specify a cpu limit percentage\n");
		print_usage(stderr, 1);
		exit(1);
	}
	float limit = perclimit/100.0;
	int cpu_count = get_cpu_count();
	if (limit<0 || limit >cpu_count) {
		fprintf(stderr,"Error: limit must be in the range 0-%d00\n", cpu_count);
		print_usage(stderr, 1);
		exit(1);
	}
	//parameters are all ok!
	signal(SIGINT, quit);
	signal(SIGTERM, quit);

	//the default priority for cpulimit
	default_priority_value = getpriority(PRIO_PROCESS, getpid());

	while(1) {
		//look for the target process..or wait for it
		int ret = 0;
		if (pid_ok) {
			//search by pid
			ret = look_for_process_by_pid(pid);
			if (ret == 0) {
				printf("No process found\n");
			}
			else if (ret < 0) {
				printf("Process found but you aren't allowed to control it\n");
			}
		}
		else {
			//search by file or path name
			ret = look_for_process_by_name(exe);
			if (ret == 0) {
				printf("No process found\n");
			}
			else if (ret < 0) {
				printf("Process found but you aren't allowed to control it\n");
			}
			else {
				pid = ret;
			}
		}
		if (ret > 0) {
			if (ret == cpulimit_pid) {
				printf("Process %d is cpulimit itself! Aborting to avoid deadlock\n", ret);
				exit(1);
			}
			printf("Process %d found\n", pid);
			//control
			limit_process(pid, limit);
		}
		if (lazy) {
			printf("Giving up...\n");
			break;
		}
		sleep(2);
	}
	
	return 0;
}

